
// Full multihub-swap-v3.rs with fixes for InvalidAccountData during initialization
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::{invoke_signed},
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

pub const STATE_SEED: &[u8] = b"state";
pub const AUTHORITY_SEED: &[u8] = b"authority";

#[derive(Debug, Default)]
pub struct ProgramState {
    pub admin: Pubkey,
    pub yot_mint: Pubkey,
    pub yos_mint: Pubkey,
    pub lp_contribution_rate: u64,
    pub admin_fee_rate: u64,
    pub yos_cashback_rate: u64,
    pub swap_fee_rate: u64,
    pub referral_rate: u64,
}

entrypoint!(process_instruction);
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    match instruction_data.first() {
        Some(0) => {
            msg!("Instruction: Initialize");
            process_initialize(program_id, accounts, instruction_data)
        }
        Some(1) => {
            msg!("Instruction: Swap");
            Ok(())
        }
        Some(2) => {
            msg!("Instruction: Close");
            Ok(())
        }
        _ => {
            msg!("Invalid instruction");
            Err(ProgramError::InvalidInstructionData)
        }
    }
}

fn process_initialize(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    input: &[u8],
) -> ProgramResult {
    let account_info_iter = &mut accounts.iter();
    let payer = next_account_info(account_info_iter)?;
    let state_account = next_account_info(account_info_iter)?;
    let authority_account = next_account_info(account_info_iter)?;
    let system_program = next_account_info(account_info_iter)?;
    let rent_sysvar = next_account_info(account_info_iter)?;

    let (expected_state, bump) = Pubkey::find_program_address(&[STATE_SEED], program_id);
    if *state_account.key != expected_state {
        msg!("❌ State PDA mismatch");
        return Err(ProgramError::InvalidAccountData);
    }

    let (expected_authority, _) = Pubkey::find_program_address(&[AUTHORITY_SEED], program_id);
    if *authority_account.key != expected_authority {
        msg!("❌ Authority PDA mismatch");
        return Err(ProgramError::InvalidAccountData);
    }

    let admin = Pubkey::new(&input[1..33]);
    let yot_mint = Pubkey::new(&input[33..65]);
    let yos_mint = Pubkey::new(&input[65..97]);
    let lp_rate = u64::from_le_bytes(input[97..105].try_into().unwrap());
    let admin_fee = u64::from_le_bytes(input[105..113].try_into().unwrap());
    let cashback = u64::from_le_bytes(input[113..121].try_into().unwrap());
    let swap_fee = u64::from_le_bytes(input[121..129].try_into().unwrap());
    let referral = u64::from_le_bytes(input[129..137].try_into().unwrap());

    let rent = Rent::from_account_info(rent_sysvar)?;
    let space = 32 * 3 + 8 * 5;
    let lamports = rent.minimum_balance(space);

    if state_account.data_is_empty() {
        msg!("Creating state account");
        invoke_signed(
            &system_instruction::create_account(
                payer.key,
                state_account.key,
                lamports,
                space as u64,
                program_id,
            ),
            &[payer.clone(), state_account.clone(), system_program.clone()],
            &[&[STATE_SEED, &[bump]]],
        )?;
    } else {
        msg!("Reinitializing existing account");
    }

    let mut data = state_account.data.borrow_mut();
    data[..32].copy_from_slice(admin.as_ref());
    data[32..64].copy_from_slice(yot_mint.as_ref());
    data[64..96].copy_from_slice(yos_mint.as_ref());
    data[96..104].copy_from_slice(&lp_rate.to_le_bytes());
    data[104..112].copy_from_slice(&admin_fee.to_le_bytes());
    data[112..120].copy_from_slice(&cashback.to_le_bytes());
    data[120..128].copy_from_slice(&swap_fee.to_le_bytes());
    data[128..136].copy_from_slice(&referral.to_le_bytes());

    msg!("✅ Initialization complete");
    Ok(())
}
